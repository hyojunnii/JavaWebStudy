--SELECT

/*
    산술연산
    칼럼 별칭 지정
    테이블에 별칭 지정
    중복제거 DISTINCT
    || 연산자로 문자열 합치기
*/

/*
    WHERE
        비교 연산자로 비교
        BETWEEN A AND B
        IS [NOT] NULL
        AND, OR
        괄호 이용해서 우선순위 지정
        LIKE % , _
        IN
*/

SELECT * FROM EMPLOYEE WHERE DEPT_CODE IN('D9','D1');

/*
    ORDER BY
        ASC, DESC
*/

/*
    --단일행 함수
        LENGTH
        LENGTHB
        INSTR : 지정한 위치부터 지정된 숫자번째까지 나타나는 문자의 시작 위치
        LPAD/RPAD : 임의의 문자를 왼쪽 또는 오른쪽에 덧붙여줌
        LTRIM/RTRIM/TRIM : 공백제거
        SUBSTR : 지정한 위치부터, 지정한 갯수만큼 문자열 추출
        LOWER/UPPER/INITCAP
        CONCAT : 문자열 합치기
        REPLACE : 변경하려는 문자 변경
        
        ABS
        MOD
        ROUND
        FLOOR
        CEIL
        TRUNC
        
        MONTHS_BETWEEN
        ADD_MONTHS
        
        EXTRACT(YEAR|MONTH|DAY FROM DATE) : 
*/

SELECT INSTR('HELLO WORLD', 'L', 2) FROM DUAL;

SELECT EXTRACT(YEAR FROM SYSDATE) FROM DUAL;

/*
    문자열 : TO_CHAR
    숫자 : TO_NUMBER
    날짜 : TO_DATE
    
    FORMAT 지정 가능
*/

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

SELECT TO_DATE('021231') FROM DUAL;


/*
    NULL 처리 함수
        NVL
        NVL2
        DECODE
        CASE ~ WHEN ~ THEN ~ ELSE ~ END
*/

SELECT EMP_NAME 사원명, SALARY 급여, SALARY*BONUS 보너스, SALARY+SALARY*NVL(BONUS,0) 총급여 FROM EMPLOYEE;

-- 보너스 동결 // 기존: 0.1, 나머지 0
SELECT EMP_NAME 사원명, 
NVL(BONUS, 0) 기존보너스율, 
NVL2(BONUS, 0.1, 0) 변경된보너스율,
(SALARY+NVL2(BONUS,0.1,0))*12 연봉
FROM EMPLOYEE;

--DECODE
SELECT EMP_ID 사번, EMP_NAME 사원명, EMP_NO 주민번호, 
DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여') 성별
FROM EMPLOYEE;

--CASE
SELECT EMP_ID 사번, EMP_NAME 사원명, EMP_NO 주민번호, 
CASE
    WHEN SUBSTR(EMP_NO,8,1) = 1 THEN '남' 
    WHEN SUBSTR(EMP_NO,8,1) = 2 THEN '여'
    ELSE '무'
END 성별
FROM EMPLOYEE;


/*
    그룹함수
        GROUP BY
        HAVING
*/

SELECT SUM(SALARY)
FROM EMPLOYEE;

SELECT DEPT_CODE, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) > 3000000;

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT COUNT(*)
FROM EMPLOYEE;

SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT DEPT_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

/*
집계함수
    CUBE
    ROLLUP
    GROUPING SETS
    
    GROUPING
*/

SELECT
    DEPT_CODE,
    GROUPING(DEPT_CODE),
    SUM(SALARY),
    AVG(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE);

/*
집합연산자
    UNION
    UNION ALL
    INTERSECT
    MINUS
*/

/*
JOIN
    INNER
    OUTER - SELF, RIGHT, FULL
    SELF
    CROSS
    
    NON EQUAL JOIN
*/

SELECT E.EMP_NAME, E.DEPT_CODE, D.DEPT_TITLE
FROM EMPLOYEE E
FULL OUTER JOIN DEPARTMENT D
ON E.DEPT_CODE = D.DEPT_ID;

--NON EQUAL JOIN (비등가 조인)
SELECT E.EMP_NAME, E.SALARY, S.SAL_LEVEL, S.MIN_SAL, S.MAX_SAL
FROM EMPLOYEE E
JOIN SAL_GRADE S
ON (E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL);

SELECT E.EMP_NAME, E.SALARY, S.SAL_LEVEL, S.MIN_SAL, S.MAX_SAL
FROM EMPLOYEE E
JOIN SAL_GRADE S
--ON (E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL); 
ON (E.SALARY > S.MIN_SAL); 